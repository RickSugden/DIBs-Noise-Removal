function save_ndacc_hdf_TEMP(data_in,path_out)

% save_ndacc_hdf(data_in, paht_out)
%
% write data to HDF4 file according to the NDACC standards for wind
% radiometry. The output filename is automatically assigned based on
% information in data_in.
%
%THIS WILL BE THE FILE FOR THE TEMPERATURE FORMAT
%
% input:
%  -data_in: export data structure for wind radiometer data. Containing 
%   data and metadata. Structure with the following fields:
%    + mandatory: station_name, latitude, longitude, instrument, time
%                 pressure, temperature, temperature_source, data_version,
%                 u_x, u_xa, u_A, u_eo, v_x, v_xa, v_A, v_eo
%    + optional:  u_low_lim, u_up_lim, u_valid,
%                 v_low_lim, v_up_lim, v_valid, t_int 
%  -path_out: output path for storage of HDF4 file
% 
% required functions:
%  -altitude_res_and_peak_from_A
%  -posixtime2datenum
%
% Rolf Ruefenacht, 2018 (based on earlier scripts by Dominik Scheiben)

exclude_untrustable=1; %excludes data beyond trustworthy altitude; I assume 1 = exclude, 0 = include

test_only=0; %for more rapid execution when testing modifications to the script

% ========== END OF PRINCIPAL INPUT =========

% ========== ADDITIONAL SETTINGS ============

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%IT APPEARS THIS IS NOT THAT IMPORTANT BCS TEST_ONLY = 0
if test_only
	%reducing amount of data for tests
	n_days_test=10;
	warning(sprintf('considering only %d days of input data for code testing. Remove this part when operational',n_days_test))
	fn=fieldnames(data_in);
	for k=1:length(fn)
		if eval(sprintf('ischar(data_in.%s)',fn{k})) %dont cut strings
			continue
		end
		if eval(sprintf('ndims(data_in.%s)<3 && size(data_in.%s,2)>n_days_test',fn{k},fn{k}))
			eval(sprintf('data_in.%s=data_in.%s(:,1:n_days_test);',fn{k},fn{k}))
		elseif eval(sprintf('ndims(data_in.%s)==3 && size(data_in.%s,3)>n_days_test',fn{k},fn{k}))
			eval(sprintf('data_in.%s=data_in.%s(:,:,1:n_days_test);',fn{k},fn{k}))
		
		end
	end
end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%we only need it to work for our LIDAR so i'm keeping the default mechanics
%and just giving it ID number 1
instrument_id = '001';

%you can simply pull all this information out of a header or some sort of
%meta data then use it to vuild the file name. Then with the name you can
%create and write the file
station_name       =  'Purple Crow Lidar';
institute_name     =  'Western';
filevers           =  '001';
data_start_date    =  datestr(posixtime2datenum(min(data_in.time)),'yyyymmddTHHMMSSZ');
data_stop_date     =  datestr(posixtime2datenum(max(data_in.time))+datenum([0,0,0,23,59,59]),'yyyymmddTHHMMSSZ');
filename           =  ['lidar_temp_' lower(institute_name) lower(instrument_id) '_' lower(station_name) '_' lower(data_start_date) '_' lower(data_stop_date) '_' filevers '.hdf'];
filepath           =  fullfile(path_out,filename);

data.altitude_instr = 280; 

disp(['Creating file ' filepath]);
fill_value         =  -90000;

% ========== DATA OPERATIONS ================
%% Some calculations for additional needed input

fprintf('\nCalculations and interpolations '), tic

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%this chunk is finding or calculating the integration time in hours
if isfield(data_in,'t_int')
	int_time = data_in.t_int/3600;
else
   	int_time = (t_stop - t_start)/3600; 
end

% An empty array is made for Altitude (in meters) it will only need one dimension because altitude is one dimensional
altitude = data_in.temp.Q.zRET;

% vertical resolution and measurement response for each day
vert_resol  = data_in.sample.width;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%runs loop through the number of time measurements
%if the column of pressure measurements is more than one element
for i = 1:length(data_in.time)
    
	if size(data_in.Q.pHSEQ_RET,2)>1 %not sure if we need this/what it does
		ind_p=i;
	else
		ind_p=1;
    end
    
    %sets the 'i th' column to the output of some crazy function of i
	altitude(:,i) =  data_in.Q.pHSEQ_RET;%refer to original to confirm if this is okay    
    vert_resol(:,i) = data_in.sample.width;
    	
end
altitude_source = 'CIRA86';


%% Interpolation to constant altitude grid
%creates an array of altitudes by in start:step:stop then transposes it
altitude_i        =  (20000:1000:90000)'; %same grid as for MIAWARA/GROMOS (-C)

%these lines create arrays of length(altitude_i) by length(data_in.time)
% there will be a value holder for each altitude at each time
%each row is for a certain altitude and each column for a time
pressure_i        =  NaN (length(altitude_i), length(data_in.time));
temperature_i     =  NaN (length(altitude_i), length(data_in.time));
i               =  NaN (length(altitude_i), length(data_in.time));
error_obs_i     =  NaN (length(altitude_i), length(data_in.time));
%error_smooth_i  =  NaN (length(altitude_i), length(data_in.time));
vert_resol_i    =  NaN (length(altitude_i), length(data_in.time));
apriori_i       =  NaN (length(altitude_i), length(data_in.time));
meas_resp_i     =  NaN (length(altitude_i), length(data_in.time));


s = warning('off','MATLAB:interp1:NaNinY');

% Interpolate daily profiles to altitude_i
for i = 1:length(data_in.time)
	if size(data_in.pressure,2)>1 %this finds the size of the 2nd dimension (columns)
		ind_p=i;
	else
		ind_p=1;
	end
	
	%full altitude range fields
    pressure_i(:,i)       =  exp(interp1 (altitude(:,i), log(data_in.Q.pHSEQ_RET(:,ind_p)), altitude_i));
    temperature_i(:,i)    =  interp1 (altitude(:,i), data_in.temperature(:,i), altitude_i);
    apriori_i(:,i)      =  interp1 (altitude(:,i), data_in.u_xa(:,i), altitude_i);
    
    
    %fields to be cut to trustworthy altitudes
    if exclude_untrustable %the default seeting is in fact to exclude untrustable
		if isfield(data_in,'u_low_lim') && isfield(data_in,'v_low_lim')
			msg_sel='selected trustworthy data based on input u/v_low_lim and u/v_up_lim';
			ind_valid = ( pressure_i(:,i)<=data_in.u_low_lim(i) & pressure_i(:,i)>=data_in.u_up_lim(i) );
			
		elseif isfield(data_in,'u_valid') && isfield(data_in,'v_valid')
			msg_sel='selected trustworthy data based on input u/v_valid';
			ind_valid = (interp1 (altitude(:,i), data_in.u_valid(:,i), altitude_i) >= 0.5);
			
		else
			error('if untrustworthy data shall be excluded fields u/v_low/up_lim or u/v_valid are madatory')
		end
	else
		msg_sel='no selection of data, all altitudes published (unless they are nan in input)';
        %these return a one dimensional array of 1s with as many elements
        %as altitude_i has rows
		ind_valid = ones(1,size(altitude_i,1));
		
    end
        i(ind_valid,i)              =  interp1 (altitude(:,i), data_in.u_x(:,i), altitude_i(ind_valid));
        error_obs_i(ind_valid,i)    =  interp1 (altitude(:,i), data_in.u_eo(:,i), altitude_i(ind_valid));
        meas_resp_i(ind_valid,i)    =  interp1 (altitude(:,i), meas_resp(:,i), altitude_i(ind_valid));
        vert_resol_i(ind_valid,i)   =  interp1 (altitude(:,i), vert_resol(:,i), altitude_i(ind_valid));
end
warning(s);
% disp(msg_sel) print out later for better structured output

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Putting everything into the "data" structure

%additional fields required for data_in
% -altitude_inst
% -altitude (altitude vector of observations in meters)
%these were calculated or found above
%data=data_in;

data.latitude              = '43.0741';
data.longitude             = '-81.3373';
data.altitude_instr        = '280';
data.time                  =  posixtime2datenum(data_in.time) - datenum(2000,1,1);                                               % 1 x time; every time needs a NaN for opacity
data.time_start            =  data_in.t_start;                                   % 1 x time  data.time is in days since Julian 01/01/2000
data.time_stop             =  data_in.t_stop;                                 % 1 x time  the data will stop one day later
data.int_time              =  data_in.t_int;                                    % 1 x time  calculated or retrieved earlier
data.altitude              =  altitude_i';                                 % time x altitude ??? shouldn't this be one dimensional

data.mixing_ratio_volume_backscatter =                                      % time x altitude
data.mixing_ratio_volume_backscatter_combined_standard_uncertainty =       %sqrt(data.vmr_random_error.^2 + data.vmr_systematic_error.^2); % time x altitude
data.mixing_ratio_volume_backscatter_random_standard_uncertainty = data_in.X.e;         % time x altitude
data.mixing_ratio_volume_backscatter_systematic_standard_uncertainty =      % time x altitude
data.humidity_relative_derived =                                            % time x altitude
data.humidity_relative_derived_combined_standard_uncertainty =              %sqrt(data.vmr_random_error.^2 + data.vmr_systematic_error.^2); % time x altitude
data.humidity_relative_derived_random_standard_uncertainty =                % time x altitude
data.humidity_relative_derived_standard_uncertainty_systematic =            % time x altitude

data.pressure              =  pressure_i'/100;                             % each row is for a certain time and each column for an altitude
data.temperature           =  temperature_i';                              % time x altitude
data.pressure_source =                                                      % time x altitude
data.temperature_source =                                                   % time x altitude

data.mixing_ratio_volume_calibration_factor =                               % time x altitude
data.mixing_ratio_volume_uncertainty_calibration_factor_originator =        % time x altitude
data.mixing_ratio_volume_calibration_source =                               % time x altitude
data.mixing_ratio_volume_resolution_altitude_df_cutoff =                    % time x altitude
data.mixing_ratio_volume_resolution_altitude_originator =                   % time x altitude
data.mixing_ratio_volume_uncertainty_originator =                           % time x altitude    
data.humidity_relative_uncertainty_originator =                             % time x altitude
data.humidity_relative =                                                    % time x altitude
data.mixing_ratio_volume_resolution_altitude_df_normalized_frequency =      % time x altitude
data.mixing_ratio_volume_resolution_altitude_df_transfer_function =         % time x altitude
data.mixing_ratio_volume_resolution_altitude_distance__from_impulse =       % time x altitude
data.mixing_ratio_volume_resolution_altitude_impulse_response =             % time x altitude
data.mixing_ratio_volume_independant =                                      % time x altitude         
data.pressure_source       =  altitude_source;                                    % string

            
if strcmpi(data_in.temperature_source,'ECMWF below 100hPa, MLS between 100 and 0.003hPa, CIRA86 above')
	zlim1 = 16e3 * ( 5 - log10(100e2) );
	zlim2 = 16e3 * ( 5 - log10(0.003e2) );
	
	data.temperature_source = cell(size(data.altitude)); 
	[data.temperature_source{:}] = deal('');           %make sure it is cell array of strings
	[data.temperature_source{data.altitude<zlim1}] = deal('ECMWF OA');
	[data.temperature_source{data.altitude>=zlim1 & data.altitude<=zlim2}] = deal('AURA MLS');
	[data.temperature_source{data.altitude>zlim2}] = deal('CIRA86  '); %left justified str padded to same length as max str length in cell array
	temperature_source_depend='ALTITUDE';
elseif ~isempty(strfind(data_in.temperature_source,'km')) || ~isempty(strfind(data_in.temperature_source,'hPa'))
	error('Do not know temperature_source string, but found altitude information (strings ''hPa'' or ''km'') in it. Adapt routine to create data dependent string array for this case.') 
else
	data.temperature_source    =  data_in.temperature_source;             % string
	temperature_source_depend='CONSTANT';
end



fprintf('took %4.0f seconds\n',toc)
disp(msg_sel)

% ========== WRITING HDF FILE ================

fprintf('\nWriting to HDF file '), tic;

%% Create the HDF file and write the global attributes

hdfml('closeall');
unix(['rm -f ' filepath ' &> /dev/null']);

% Create the HDF4 file
SD_id = matlab.io.hdfeos.sd('start',filepath,'create');

% Set global attributes
% All the attributes in the IDL script are present here
% They don't appear to need any further modification 
matlab.io.hdfeos.sd('setattr',SD_id,'PI_NAME','Sica;Robert');
matlab.io.hdfeos.sd('setattr',SD_id,'PI_AFFILIATION','Western University;UWO'); 
matlab.io.hdfeos.sd('setattr',SD_id,'PI_ADDRESS','Sidlerstrasse 5;CH-3012 Bern;SWITZERLAND'); %needs to be changed
matlab.io.hdfeos.sd('setattr',SD_id,'PI_EMAIL','sica@uwo.ca'); 
matlab.io.hdfeos.sd('setattr',SD_id,'DO_AFFILIATION','Western University;UWO'); 
matlab.io.hdfeos.sd('setattr',SD_id,'DS_AFFILIATION','Western University;UWO'); 
matlab.io.hdfeos.sd('setattr',SD_id,'DO_ADDRESS','Sidlerstrasse 5;CH-3012 Bern;SWITZERLAND'); %needs to be changed
matlab.io.hdfeos.sd('setattr',SD_id,'DS_ADDRESS','Sidlerstrasse 5;CH-3012 Bern;SWITZERLAND'); %needs to be changed
%these are slightly out of order but that's only because the changing
%fields should be grouped together in the if statement
%if str2num(instrument_id)==1 % we may not need an if statement here at all if its just uwo
matlab.io.hdfeos.sd('setattr',SD_id,'DO_NAME','Sica;Robert'); 
matlab.io.hdfeos.sd('setattr',SD_id,'DO_EMAIL','sica@uwo.ca'); 
matlab.io.hdfeos.sd('setattr',SD_id,'DS_NAME','Sica;Robert');
matlab.io.hdfeos.sd('setattr',SD_id,'DS_EMAIL','sica@uwo.ca'); 

end
matlab.io.hdfeos.sd('setattr',SD_id,'DATA_DESCRIPTION','Atmospheric wind profiles from campaign-based measurements of ground-based 142.175 GHz-microwave radiometer WIRA. NOTE: Measurements in north- and southward directions are combined to one meridionaland wind profile; Measurements from east- and westward directions are combined to one zonal wind profile.');
matlab.io.hdfeos.sd('setattr',SD_id,'DATA_DISCIPLINE','ATMOSPHERIC.PHYSICS;REMOTE.SENSING;GROUNDBASED');
matlab.io.hdfeos.sd('setattr',SD_id,'DATA_GROUP','EXPERIMENTAL;PROFILE.STATIONARY');
matlab.io.hdfeos.sd('setattr',SD_id,'DATA_LOCATION',data_in.station_name);
matlab.io.hdfeos.sd('setattr',SD_id,'DATA_SOURCE',['MWR.WIND_UBERN',instrument_id]);
matlab.io.hdfeos.sd('setattr',SD_id,'DATA_START_DATE',data_start_date);
matlab.io.hdfeos.sd('setattr',SD_id,'DATA_STOP_DATE',data_stop_date);
matlab.io.hdfeos.sd('setattr',SD_id,'DATA_FILE_VERSION',filevers);
matlab.io.hdfeos.sd('setattr',SD_id,'DATA_MODIFICATIONS','24-hour retrieval');
matlab.io.hdfeos.sd('setattr',SD_id,'DATA_CAVEATS','Wind profiles are estimated  by ARTS2/QPACK2 retrieval software, fast fourier transform spectrometer, calibration with tipping curve');
matlab.io.hdfeos.sd('setattr',SD_id,'DATA_RULES_OF_USE','Please contact Niklaus Kaempfer at niklaus.kaempfer@iap.unibe.ch');%this might have to be changed
matlab.io.hdfeos.sd('setattr',SD_id,'DATA_ACKNOWLEDGEMENT',['The middle atmospheric wind radiometer ' data_in.instrument ' is operated by the Institute of Applied Physics, University of Bern, Switzerland.']);
matlab.io.hdfeos.sd('setattr',SD_id,'DATA_QUALITY',' '); %RD removed
matlab.io.hdfeos.sd('setattr',SD_id,'DATA_TEMPLATE','GEOMS-TE-MWR-WIND-001');
matlab.io.hdfeos.sd('setattr',SD_id,'DATA_PROCESSOR',['Retrieval version' data_in.data_version ' from microwave wind radiometer ' data_in.instrument]);
matlab.io.hdfeos.sd('setattr',SD_id,'FILE_NAME',filename);
matlab.io.hdfeos.sd('setattr',SD_id,'FILE_GENERATION_DATE',datestr(now,'yyyymmddTHHMMSSZ'));
matlab.io.hdfeos.sd('setattr',SD_id,'FILE_ACCESS','NDACC');
matlab.io.hdfeos.sd('setattr',SD_id,'FILE_PROJECT_ID',' ');
matlab.io.hdfeos.sd('setattr',SD_id,'FILE_DOI',' ');
matlab.io.hdfeos.sd('setattr',SD_id,'FILE_ASSOCIATION',' ');
matlab.io.hdfeos.sd('setattr',SD_id,'FILE_META_VERSION','04R026;CUSTOM');




%% Initialize several structures that will be used when writing the Scientific Data Sets (SDS)
%I have made up the names here and i dont know why only the first two are
%data_in....
        
 SDS_Name_List = {data.LATITUDE.INSTRUMENT ...
                 data.LONGITUDE.INSTRUMENT ...
                 data.ALTITUDE.INSTRUMENT ...
                 data.DATETIME ...
                 data.DATETIME.START ...
                 data.DATETIME.STOP ...
                 data.INTEGRATION.TIME ...
                 data.ALTITUDE ...
                 data.TEMPERATURE_BACKSCATTER...
                 data.TEMPERATURE_BACKSCATTER_UNCERTAINTY.COMBINED.STANDARD...
                 data.TEMPERATURE_BACKSCATTER_UNCERTAINTY.RANDOM.STANDARD...
                 data.TEMPERATURE_BACKSCATTER_UNCERTAINTY.SYSTEMATIC.STANDARD...
                 data.TEMPERATURE_BACKSCATTER_RESOLUTION.ALTITUDE.IMPULSE.RESPONSE.FWHM...
                 data.NUMBER.DENSITY_BACKSCATTER ...
                 data.NUMBER.DENSITY_BACKSCATTER_UNCERTAINTY.COMBINED.STANDARD ...
                 data.NUMBER.DENSITY_BACKSCATTER_UNCERTAINTY.RANDOM.STANDARD...
                 data.NUMBER.DENSITY_BACKSCATTER_UNCERTAINTY.SYSTEMATIC.STANDARD...
                 data.NUMBER.DENSITY_INDEPENDANT ...
                 data.PRESSURE_INDEPENDANT ...
                 data.TEMPERATURE_INDEPENDANT ...
                 data.NUMBER.DENSITY_INDEPENDANT_SOURCE ...
                 data.PRESSURE_INDEPENDANT_SOURCE ...
                 data.TEMPERATURE_INDEPENDANT_SOURCE ...
                 data.ALTITUDE_INDEPENDANT_NORMALIZATION ...
                 data.ALTITUDE_INDEPENDANT_INITIALIZATION ...
                 data.TEMPERATURE_BACKSCATTER_RESOLUTION.ALTITUDE.DF.CUTOFF...
                 data.TEMPERATURE_BACKSCATTER_UNCERTAINTY.ORIGINATOR...
                 data.TEMPERATURE_BACKSCATTER_RESOLUTION.ALTITUDE.ORIGINATOR...
                 data.NUMBER.DENSITY_BACKSCATTER_UNCERTAINTY.ORIGINATOR...
                 data.TEMPERATURE_BACKSCATTER_RESOLUTION.ALTITUDE.DF.NORMALIZED.FREQUENCY...
                 data.TEMPERATURE_BACKSCATTER_RESOLUTION.ALTITUDE.DF.TRANSFER.FUNCTION...
                 data.TEMPERATURE_BACKSCATTER_RESOLUTION.ALTITUDE.DISTANCE.FROM.IMPULSE...
                 data.TEMPERATURE_BACKSCATTER_RESOLUTION.ALTITUDE.IMPULSE.RESPONSE ...
                 data.SOURCE.PRODUCT};
             
SDS_Name_List = {'LATITUDE.INSTRUMENT', ...
                 'LONGITUDE.INSTRUMENT', ...
                 'ALTITUDE.INSTRUMENT', ...
                 'DATETIME', ...
                 'DATETIME.START', ...
                 'DATETIME.STOP', ...
                 'INTEGRATION.TIME', ...
                 'ALTITUDE', ...
                 'TEMPERATURE_BACKSCATTER',...
                 'TEMPERATURE_BACKSCATTER_UNCERTAINTY.COMBINED.STANDARD',...
                 'TEMPERATURE_BACKSCATTER_UNCERTAINTY.RANDOM.STANDARD',...
                 'TEMPERATURE_BACKSCATTER_UNCERTAINTY.SYSTEMATIC.STANDARD',...
                 'TEMPERATURE_BACKSCATTER_RESOLUTION.ALTITUDE.IMPULSE.RESPONSE.FWHM',...
                 'NUMBER.DENSITY_BACKSCATTER', ...
                 'NUMBER.DENSITY_BACKSCATTER_UNCERTAINTY.COMBINED.STANDARD', ...
                 'NUMBER.DENSITY_BACKSCATTER_UNCERTAINTY.RANDOM.STANDARD',...
                 'NUMBER.DENSITY_BACKSCATTER_UNCERTAINTY.SYSTEMATIC.STANDARD',...
                 'NUMBER.DENSITY_INDEPENDANT', ...
                 'PRESSURE_INDEPENDANT', ...
                 'TEMPERATURE_INDEPENDANT', ...
                 'NUMBER.DENSITY_INDEPENDANT_SOURCE', ...
                 'PRESSURE_INDEPENDANT_SOURCE', ...
                 'TEMPERATURE_INDEPENDANT_SOURCE', ...
                 'ALTITUDE_INDEPENDANT_NORMALIZATION', ...
                 'ALTITUDE_INDEPENDANT_INITIALIZATION', ...
                 'TEMPERATURE_BACKSCATTER_RESOLUTION.ALTITUDE.DF.CUTOFF',...
                 'TEMPERATURE_BACKSCATTER_UNCERTAINTY.ORIGINATOR',...
                 'TEMPERATURE_BACKSCATTER_RESOLUTION.ALTITUDE.ORIGINATOR',...
                 'NUMBER.DENSITY_BACKSCATTER_UNCERTAINTY.ORIGINATOR',...
                 'TEMPERATURE_BACKSCATTER_RESOLUTION.ALTITUDE.DF.NORMALIZED.FREQUENCY',...
                 'TEMPERATURE_BACKSCATTER_RESOLUTION.ALTITUDE.DF.TRANSFER.FUNCTION',...
                 'TEMPERATURE_BACKSCATTER_RESOLUTION.ALTITUDE.DISTANCE.FROM.IMPULSE',...
                 'TEMPERATURE_BACKSCATTER_RESOLUTION.ALTITUDE.IMPULSE.RESPONSE', ...
                 'SOURCE.PRODUCT'};
             
SDS_DataType_List = {'float', ...
                     'float', ...
                     'float', ...
                     'double', ...
                     'double', ...
                     'double', ...
                     'float', ...
                     'float', ...
                     'float', ...
                     'float', ...
                     'float', ...
                     'float', ...
                     'float', ...
                     'float', ...
                     'float', ...
                     'float', ...
                     'float',...
                     'float', ...
                     'float', ...
                     'string', ...
                     'string', ...
                     'string', ...
                     'float',...
                     'float', ...
                     'float', ...
                     'float', ...
                     'float', ...
                     'float', ...
                     'float', ...
                     'float', ...
                     'float', ...
                     'float', ...
                     'float', ...
                     'string'};
VAR_DESCRIPTION_List = {'Inst. latitude (+ for north; - for south) (deg)', ...
                        'Inst. longitude (+ for east; - for west) (deg)', ...
                        'Inst. altitude(m)', ...
                        'Weighted meas. Time', ...
                        'Meas. start', ...
                        'Meas. stop', ...
                        'Actual integration time', ...
                        'Actual meas. grid (increasing)', ...
                        'Raman or Rayleigh-Brillouin',...
                        'Uncertainty: NDACC-lidar-standardized definition',...
                        'Random uncertainty: NDACC-lidar-standardized definition'
                        'Systematic uncertainty: NDACC-lidar-standardized definition', ...
                        'Vertical resolution: Full-width at half-maximum (FWHM) of impulse response',...
                        'From lidar measurement',...
                        'Uncertainty: NDACC-lidar-standardized definition', ...
                        'Random uncertainty: NDACC-lidar-standardized definition', ...
                        'Systematic uncertainty: NDACC-lidar-standardized definition', ...
                        'Air number density profile used for normalization', ...
                        'Pressure profile used for initialization', ...
                        'Temperature profile used for initialization', ...
                        'Air number density profile source (e.g. Lidar; NCEP; Sonde; ECMWF etc.)', ...
                        'Pressure profile source (e.g. Lidar; NCEP; Sonde; ECMWF etc.)',...                
                        'Temperature profile source (e.g. Lidar; NCEP; Sonde; ECMWF etc.)', ...
                        'Altitude of Normalization (scalar)', ...
                        'Altitude of Initialization (scalar)', ...
                        'Vertical resolution: NDACC-lidar-standardized based on digital filter cut-off frequency', ...
                        'Uncertainty: Following PIs historical definition', ...
                        'Vertical resolution: PIs historical definition', ...
                        'Uncertainty: Following PIs historical definition', ...
                        'Normalized frequency (in 1/bins) to use with Transfer Function (Nyquist=0.5)', ...
                        'Transfer Function of Digital Filter used', ...
                        'Distance from impulse (in bins) to use with Impulse Response (0 at location of Impulse)', ...
                        'Vertical resolution: impulse response', ...
                        'Information relevant to the source history of the Metadata and Data'};                                           
VAR_NOTES_List = {' ', ...
                  ' ', ...
                  ' ', ...
                  ' ', ...
                  ' ', ...
                  ' ', ...
                  ' ', ...
                  ' ', ...
                  ' ', ...
                  ' ', ...
                  ' ', ...
                  ' ', ...
                  ' ', ...
                  ' ',...
                  ' ', ...
                  ' ', ...
                  ' ', ...
                  ' ', ...
                  ' ', ...
                  ' ', ...
                  ' ', ...
                  ' ',...
                  ' ', ...
                  ' ', ...
                  ' ', ...
                  ' ', ...
                  ' ', ...
                  ' ', ...
                  ' ', ...
                  ' ',...
                  ' ', ...
                  ' ',...
                  ' ', ...
                  ' '};                   
VAR_DEPEND_List = {'CONSTANT', ...             
                   'CONSTANT', ...
                   'CONSTANT', ...
                   'DATETIME', ...
                   'DATETIME', ...
                   'DATETIME', ...
                   'DATETIME', ...
                   'ALTITUDE', ...
                   'ALTITUDE', ...
                   'ALTITUDE', ...
                   'ALTITUDE', ...
                   'ALTITUDE', ...
                   'ALTITUDE', ...
                   'ALTITUDE', ...
                   'ALTITUDE', ...
                   'TEMPERATURE_BACKSCATTER_RESOLUTION.ALTITUDE.DF.NORMALIZED.FREQUENCY', ...
                   'TEMPERATURE_BACKSCATTER_RESOLUTION.ALTITUDE.DF.NORMALIZED.FREQUENCY;ALTITUDE', ...
                   'ALTITUDE', ...
                   'TEMPERATURE_BACKSCATTER_RESOLUTION.ALTITUDE.DISTANCE.FROM.IMPULSE', ...
                   'ALTITUDE;ALTITUDE','TEMPERATURE_BACKSCATTER_RESOLUTION.ALTITUDE.DISTANCE.FROM.IMPULSE;ALTITUDE' ...
                   'ALTITUDE', ...
                   'ALTITUDE', ...
                   'ALTITUDE', ...
                   'ALTITUDE', ...
                   'ALTITUDE', ...
                   'ALTITUDE', ...
                   'CONSTANT', ...             
                   'ALTITUDE', ...
                   'ALTITUDE', ...
                   'ALTITUDE', ...
                   'CONSTANT', ...
                   'ALTITUDE',...
                   'ALTITUDE',...
                   'INDEPENDANT'};               
VAR_UNITS_List = {'deg', ...
                  'deg', ...
                  'm', ...
                  'MJD2K', ...
                  'MJD2K', ...
                  'MJD2K', ...
                  'h', ...
                  'm', ...
                  'K', ...
                  'K', ...
                  'K', ...
                  'K', ...
                  'm', ...
                  'molec m-3', ...
                  'molec m-3', ...
                  'molec m-3', ...
                  'molec m-3', ...
                  'molec m-3', ...
                  'hPa', ...
                  'K', ...
                  ' ',...
                  ' ',...
                  ' ',...
                  'm', ...
                  'm', ...
                  'm', ...
                  'K', ...
                  'm', ...
                  'molec m-3', ...
                  '1', ...
                  '1',...
                  '1', ...
                  '1', ...                 
                  ' '};    
VAR_SI_CONVERSION_List = {'0.0;1.74533E-2;rad', ...
                          '0.0;1.74533E-2;rad', ...
                          '0;1;m', ...
                          '0.0;86400.0;s', ...
                          '0.0;86400.0;s', ...
                          '0.0;86400.0;s', ...
                          '0.0;3600.0;s', ...
                          '0;1;m', ...
                          '0;1;K', ...
                          '0;1;K', ...
                          '0;1;K', ...
                          '0;1;K', ...
                          '0;1;m', ...
                          '0.0;1.66054E-24;mol m-3',...
                          '0.0;1.66054E-24;mol m-3',...
                          '0.0;1.66054E-24;mol m-3',...
                          '0.0;1.66054E-24;mol m-3',...
                          '0.0;1.66054E-24;mol m-3',...
                          '0.0;1.0E2;kg m-1 s-2'
                          '0;1;K', ...
                          ' ',...
                          ' ',...
                          ' ',...
                          '0;1;m', ...
                          '0;1;m', ...
                          '0;1;m', ...
                          '0;1;K', ...
                          '0;1;m',...
                          '0.0;1.66054E-24;mol m-3',...
                          '0;1;1', ...
                          '0;1;1',...
                          '0;1;1' ...
                          '0;1;1' ...
                          ' '};
VAR_VALID_MIN_List = {-90, ...
                      -180, ...
                      -300, ...
                      -36600, ...
                      floor(min(data_in.t_start)), ...
                      floor(min(data_in.t_start)), ...
                      0, ...
                      -300,...
                      50,...
                      0, ...
                      0, ...
                      0, ...
                      0, ...
                      0, ...
                      0, ...
                      0, ...
                      -1, ...
                      0, ...
                      -dmax,...%???
                      -1, ...
                      2.0000000e+014,...
                      0, ...
                      0, ...
                      0, ...
                      0, ...
                      2.0000000e+014, ...
                      -300,...
                      ' ',...
                      0.001, ...
                      50, ...
                      -300, ...
                      ' ', ...
                      ' ', ...
                      ' '};
VAR_VALID_MAX_List = {90, ...
                      180, ...
                      20000, ...
                      36600, ...
                      ceil(max(data.time_start)), ...% These are a 
                      ceil(max(data.time_stop)), ...%
                      50,...% can't say this seems intuitive to me
                      120000, ...
                      420,...
                      50,...
                      50,...
                      50,...
                      50,...
                      35000,...
                      25000,...
                      0.5,...
                      1,...
                      10000, ...
                      dmax,...
                      1, ...
                      4.0000000e+025, ...
                      1.0000000e+023,...
                      1.0000000e+023,...
                      1.0000000e+023,...
                      1.0000000e+023,...
                      4.0000000e+025,...
                      120000,...
                      ' ',...
                      1100,...
                      420,...
                      120000,...
                      ' ',...
                      ' ',...
                      ' '};


for SDS_ind = 1:length(SDS_Name_List)
	if strcmpi(SDS_Name_List{SDS_ind},'DATETIME')
		ind_datetime=SDS_ind;
	elseif strcmpi(SDS_Name_List{SDS_ind},'ALTITUDE')
		ind_altitude=SDS_ind;
	end
end
if ~exist('ind_datetime','var')
	error('Field ''DATETIME'' is mandatory in SDS')
end
if ~exist('ind_altitude','var')
	error('Field ''ALTITUDE'' is mandatory in SDS')
end


%% Write the Scientific Data Sets (SDS)
str_vars=[];
for SDS_ind = 1:length(SDS_Name_List)
    
    % Define the name and some other information
    name = SDS_Name_List{SDS_ind};

    % Read the data
    value = HDF_data{SDS_ind};
    
    if ~iscell(value) && all(all(all(isnan(value)))) %exclude variables which just have fill values (insnan cannot operate on cell but cell arrays are never empty in this script)
		fprintf('\n - %s skipped (only fill values)',name)
		continue
	end
	
	fprintf('\n + %s',name);tic
    
	str_vars=sprintf('%s%s;',str_vars,name); %needs to be after continue statement to exclude unset variables
    if strcmpi(SDS_DataType_List{SDS_ind},'string') || strcmpi(SDS_DataType_List{SDS_ind},'char')
		fill_value_act = ' ';
		type = 'char'; 
		if iscell(value) %cellstr cannot easily be written to hdf4 with matlab. convert to character matrix
			lstr=length(value{1});
			if ~all(cellfun('Length',value)==lstr) 
				error(sprintf('cellstr elements must all have the same length of strings. pad with empty spaces at the end if necessary. The problem was detected for %s'),name)
			end
			value=vertcat(value{:});
			rank = 2;
			dims = size(value);
		else
			rank = 1;
			dims = size(value,2);
		end
    else
		fill_value_act = fill_value;
		pval=permute(value,circshift(1:ndims(value),[0,-1])); %use permutation to return day index in last call of min/max
		[min_value ind_min] = min(pval);
		[max_value ind_max] = max(pval);
		ct_while=0;
		while ~isscalar(min_value)
			[min_value ind_min] = min(min_value);
			[max_value ind_max] = max(max_value);
			ct_while=ct_while+1;
			if ct_while>10
				error(sprintf('min and max values are still not scalar after 10 executions of min/max. Is the dimension of %s larger than 10?',name))
			end
		end
		if min_value<VAR_VALID_MIN_List{SDS_ind} || max_value>VAR_VALID_MAX_List{SDS_ind}
			throw_error=1;
			%if avk is out of range at high altitudes well beyond trustworthy range replace by fill value and continue
			if strcmpi(name,'WIND.ZONAL_EMISSION_AVK') || strcmpi(name,'WIND.MERIDIONAL_EMISSION_AVK') ...
				|| strcmpi(name,'WIND.ZONAL_EMISSION.AVK') || strcmpi(name,'WIND.MERIDIONAL_EMISSION.AVK')
				[min_value ind_min] = min(min(min(pval(altitude_i<85e3,altitude_i<85e3,:))));
				[max_value ind_min] = max(max(max(pval(altitude_i<85e3,altitude_i<85e3,:))));
				if ~(min_value<VAR_VALID_MIN_List{SDS_ind} || max_value>VAR_VALID_MAX_List{SDS_ind})
					ind_cut = value<VAR_VALID_MIN_List{SDS_ind} | value>VAR_VALID_MAX_List{SDS_ind} ;
					value(ind_cut) =  fill_value_act;
					throw_error=0;
				end
			end
			if throw_error
				if min_value<VAR_VALID_MIN_List{SDS_ind}
					error(sprintf('%s is out of range (below min) for index %d, date %s. Minimum found is %.2f but specified min value is %.2f',name,ind_min,datestr(data.time(ind_min)+datenum(2000,1,1)),min_value,VAR_VALID_MIN_List{SDS_ind}));
				else
					error(sprintf('%s is out of range (above max) for index %d, date %s. Maximum found is %.2f but specified max value is %.2f',name,ind_max,datestr(data.time(ind_max)+datenum(2000,1,1)),max_value,VAR_VALID_MAX_List{SDS_ind}));
				end
			end
		end
		value(isnan(value)) = fill_value;
		
		% Convert the data to the required data type
		switch SDS_DataType_List{SDS_ind}
			case 'float'
				value = single(value);
			case 'int32'
				value = int32(value);
			case 'double'
				value = double(value);
		end            
		
		A = whos('value');
		type = A.class;
		if strcmpi(type,'single')
			type = 'float';
		end
		if length(size(value))==2 && size(value,1)==1 && size(value,2)==1
			rank = 1;
			dims = 1;
		elseif length(size(value))==2 && size(value,1)==1 && size(value,2)>1
			rank = 1;
			dims = size(value,2);
		else
			rank = ndims(value);
			dims = size(value);  
		end
    end

    % Create the SDS
    sds_id = matlab.io.hdfeos.sd('create',SD_id,name,type,rank,dims);

    % The variable sizes need to be consistent with the VAR_SIZE Attribute
    depend_ind = strfind(VAR_DEPEND_List{SDS_ind},';');
    depend_names = {};
    if isempty(depend_ind)
        depend_names = {VAR_DEPEND_List{SDS_ind}};
    elseif length(depend_ind) == 1
        depend_names = {VAR_DEPEND_List{SDS_ind}(1:depend_ind(1)-1),VAR_DEPEND_List{SDS_ind}(depend_ind(1)+1:end)};
    elseif length(depend_ind) == 2
        depend_names = {VAR_DEPEND_List{SDS_ind}(1:depend_ind(1)-1),VAR_DEPEND_List{SDS_ind}(depend_ind(1)+1:depend_ind(2)-1),VAR_DEPEND_List{SDS_ind}(depend_ind(2)+1:end)};
    end
    
    if strcmpi(depend_names{1},'CONSTANT') || strcmpi(depend_names{1},'INDEPENDENT')
		if strcmpi(name,'ANGLE.VIEW_AZIMUTH')
			var_size_str = '4';
		else
			var_size_str = '1';
		end
    elseif strcmpi(depend_names{1},'DATETIME') && length(depend_names)==1
        var_size_str = num2str(length(HDF_data{ind_datetime}));
    elseif strcmpi(depend_names{1},'ALTITUDE') && length(depend_names)==1
        var_size_str = num2str(length(HDF_data{ind_altitude}));
    elseif strcmpi(depend_names{1},'DATETIME') && length(depend_names)==2 && strcmpi(depend_names{2},'ALTITUDE')
        var_size_str = [num2str(length(HDF_data{ind_datetime})) ';' num2str(length(HDF_data{ind_altitude}))];
    elseif strcmpi(depend_names{1},'DATETIME') && length(depend_names)==3 && strcmpi(depend_names{2},'ALTITUDE') && strcmpi(depend_names{3},'ALTITUDE')
        var_size_str = [num2str(length(HDF_data{ind_datetime})) ';' num2str(length(HDF_data{ind_altitude})) ';' num2str(length(HDF_data{ind_altitude}))];
    else
        error(sprintf('cannot write var_size_str for %s. Situation unknown.',name));
    end
    
    % Add attribute to the SDS
    matlab.io.hdfeos.sd('setattr',sds_id,'VAR_NAME',name);
    matlab.io.hdfeos.sd('setattr',sds_id,'VAR_DESCRIPTION',VAR_DESCRIPTION_List{SDS_ind});
    matlab.io.hdfeos.sd('setattr',sds_id,'VAR_NOTES',VAR_NOTES_List{SDS_ind});
    matlab.io.hdfeos.sd('setattr',sds_id,'VAR_SIZE',var_size_str);
    matlab.io.hdfeos.sd('setattr',sds_id,'VAR_DEPEND',VAR_DEPEND_List{SDS_ind});
    if strcmpi(type,'float')
        var_data_type = 'REAL';
    elseif strcmpi(type,'double')
        var_data_type = 'DOUBLE';
    elseif strcmpi(type,'int32')
        var_data_type = 'INTEGER';
    elseif strcmpi(type,'char')		
        var_data_type = 'STRING';
    end
    matlab.io.hdfeos.sd('setattr',sds_id,'VAR_DATA_TYPE',var_data_type);
    matlab.io.hdfeos.sd('setattr',sds_id,'VAR_UNITS',VAR_UNITS_List{SDS_ind});
    matlab.io.hdfeos.sd('setattr',sds_id,'VAR_SI_CONVERSION',VAR_SI_CONVERSION_List{SDS_ind});
    if strcmpi(type,'float')
        type_matlab = 'single';
    else
        type_matlab = type;
    end
    eval(['hdfsd(' char(39) 'setattr' char(39) ',sds_id,' char(39) 'VAR_VALID_MIN' char(39) ',' type_matlab '(VAR_VALID_MIN_List{SDS_ind}));']);
    eval(['hdfsd(' char(39) 'setattr' char(39) ',sds_id,' char(39) 'VAR_VALID_MAX' char(39) ',' type_matlab '(VAR_VALID_MAX_List{SDS_ind}));']);
    eval(['hdfsd(' char(39) 'setattr' char(39) ',sds_id,' char(39) 'VAR_FILL_VALUE' char(39) ',' type_matlab '(fill_value_act));']);
    eval(['hdfsd(' char(39) 'setattr' char(39) ',sds_id,' char(39) 'valid_range' char(39) ',' type_matlab '([VAR_VALID_MIN_List{SDS_ind} VAR_VALID_MAX_List{SDS_ind}]));']);
    matlab.io.hdfeos.sd('setattr',sds_id,'units',VAR_UNITS_List{SDS_ind});
    eval(['hdfsd(' char(39) 'setattr' char(39) ',sds_id,' char(39) '_FillValue' char(39) ',' type_matlab '(fill_value_act));']);
    
    % Write data to the SDS
    ds_start = zeros(1,rank); % Start at the beginning	
    ds_stride = [];               % Write every element. 
    
    % For the HDF, some dimensions need to be flipped while storing the data.
    if rank == 1
        ds_edges = fliplr(dims);   % Reverse the dimensions.
        matlab.io.hdfeos.sd('writedata',sds_id,ds_start, ds_stride, ds_edges, value);
    elseif rank == 2
        ds_edges = dims;   % Don't reverse the dimensions.
        matlab.io.hdfeos.sd('writedata',sds_id,ds_start, ds_stride, ds_edges, permute(value,[2 1]));
    elseif rank == 3
        ds_edges = dims;   % Don't reverse the dimensions.
        matlab.io.hdfeos.sd('writedata',sds_id,ds_start, ds_stride, ds_edges, permute(value,[3 2 1]));
    end
                     
    % Close the SDS
    matlab.io.hdfeos.sd('endaccess',sds_id);
    fprintf(' (took %4.2f seconds)',toc)

end

str_vars(end)=[]; %remove tailing semicolon
matlab.io.hdfeos.sd('setattr',SD_id,'DATA_VARIABLES',str_vars);

%% Close the HDF4 file

matlab.io.hdfeos.sd('end',SD_id);


% Final user messages
%fprintf('\ntook %4.0f seconds\n',toc)
fprintf('\n\nData successfully written to the following HDF4 file:');
disp(filepath);


